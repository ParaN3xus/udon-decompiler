# Udon Decompiler: LLM Context

## Project summary
- Python decompiler for UdonSharp/Udon programs.
- Input is a JSON dump of a Udon program (generated by Unity editor scripts).
- Output is pseudo C# code (formatted by clang-format).

## High-level flow
1) Unity editor script `UdonProgramDumper` dumps `serializedProgramCompressedBytes` into JSON (see `Editor/`).
2) CLI loads `UdonModuleInfo.json` (external, not stored in repo).
3) `ProgramLoader` parses JSON into `UdonProgramData`.
4) `BytecodeParser` disassembles bytecode to `Instruction` list.
5) `DataFlowAnalyzer` builds CFGs and performs stack simulation, variable discovery, expression building.
6) `ASTBuilder` uses `SCFGAdapter` (numba-scfg) + SCFG raw emitter + lifter pipeline to structure control-flow.
7) `ProgramCodeGenerator` builds a program AST and `CSharpCodeGenerator` emits formatted C#.

## Key entry points
- CLI: `udon-decompiler` (see `udon_decompiler/__main__.py`).
- Library entry: `decompile_program_to_source` in `udon_decompiler/__init__.py`.

## Dumped program JSON format (input)
`ProgramLoader` expects a JSON object with these fields:
- `byteCodeHex`: hex string for bytecode.
- `byteCodeLength`: byte length of bytecode.
- `symbols`: map of symbol name -> `{name, type, address}`.
- `entryPoints`: list of `{name, address}` (address is bytecode offset).
- `heapInitialValues`: map of address (string) -> `{address, type, value:{isSerializable, value}}`.

Mapping details:
- `entryPoints[i].address` becomes `EntryPointInfo.address`; `call_jump_target` is set to `address + OpCode.PUSH.size`.
- `heapInitialValues` keys are parsed as ints; values become `HeapEntry` and `HeapEntryValue`.

## Repo layout (core)
- `udon_decompiler/`
  - `loaders/`: parse JSON program + module info.
  - `parsers/`: `BytecodeParser`.
  - `analysis/`: CFG, stack sim, expression + variable analysis, SCFG adapter.
  - `codegen/`: AST building + SCFG emitter + C# generation.
  - `models/`: program/instruction/module info data structures.
  - `utils/`: logging helpers.
- `Editor/`: Unity editor scripts (module info extractor, program dumper, UdonSharp compiler).
- `tests/`: markdown-driven test cases + snapshot tests.
- `docs/`: Typst documentation for architecture, Udon VM notes, etc.

## Editor scripts (Unity)
- `Editor/UdonProgramDumper.cs`: reads `serializedProgramCompressedBytes`, deserializes via OdinSerializer, and dumps JSON for Python.
- `Editor/UdonModuleInfoExtractor.cs`: extracts `UdonModuleInfo.json` from a Unity project.
- `Editor/UdonSharpSourceTextCompiler*.cs`: compiles UdonSharp source snippets for test cases (used in CI).

## Core data structures
- `UdonProgramData` (`udon_decompiler/models/program.py`):
  - `byte_code_hex`, `byte_code_length`, `symbols`, `entry_points`, `heap_initial_values`.
  - `get_class_name()` uses heap entry at address 1 for `__refl_typename`.
- `Instruction` + `OpCode` (`udon_decompiler/models/instruction.py`).
- `UdonModuleInfo` (`udon_decompiler/models/module_info.py`): external function metadata.

## Disassembly and analysis
- `BytecodeParser` reads big-endian u32 opcode/operand pairs.
- `CFGBuilder` builds control flow graphs per entry point.
- `FunctionDataFlowAnalyzer`:
  - stack simulation (`StackSimulator`),
  - variable identification (`VariableIdentifier`),
  - expression building (`ExpressionBuilder`).

## Code generation
- `ASTBuilder` builds per-function AST via `SCFGAdapter` + `SCFGRawEmitter`, then runs the lifter pipeline.
- `ProgramCodeGenerator` collects functions + globals into `ProgramNode`.
- `CSharpCodeGenerator` emits pseudo C# and runs `clang-format` (must be on PATH).

## SCFG (Structured CFG)
- `analysis/scfg_adapter.py` maps CFG blocks into `numba-scfg` blocks (including switch).
- `codegen/scfg_lifters/raw_emitter.py` walks SCFG regions and emits raw AST nodes.
- `codegen/scfg_lifters/pipeline.py` applies lifting passes to improve structure/readability.
- numba-scfg may introduce synthetic control variables; the lifters remove or inline them.

### SCFG lifter pipeline (current order)
1) `LoopLifter`
2) `BackedgeLifter`
3) `ExitVarLifter`
4) `ControlVarLifter`
5) `CleanupLifter`
6) `WhileTrueLifter`
7) `CleanupLifter` (2nd pass)

## Tests and snapshots
- Test cases live in `tests/cases/**.md`.
- Each markdown file has exactly 1 or 2 fenced code blocks:
  - block 1: C# source snippet (UdonSharp input).
  - block 2: dumped program JSON (optional, auto-updated by CI).
- `<!-- ci: skip-compile -->` directive skips a case during Unity compilation.
- Parser enforces the 1-or-2 block rule (`tests/ci/md_cases.py`).
- Snapshot tests: `tests/test_snapshots.py` uses `syrupy`.
  - Reads dumped JSON block, decompiles, and compares with `snaps/*.cs`.
  - `UDON_MODULE_INFO` env var points to `UdonModuleInfo.json` (tests skip if missing).

### Writing test cases (markdown-driven)
1) Create or edit `tests/cases/**.md` with a C# fenced block (UdonSharp input).
2) Optionally leave a second JSON block empty or omit it; CI will fill it.
3) If the case should not be compiled in Unity CI, add `<!-- ci: skip-compile -->`.

### CI compilation flow (remote)
- After you push, the `compile-test-cases.yml` workflow compiles the C# snippets in Unity.
- It writes the compiled dumped JSON back into the markdown as the 2nd code block.
- Pull the repo to get the completed/updated dumped JSON blocks.

### Local snapshot update
- Run `pytest --snapshot-update` to regenerate `tests/cases/**/snaps/*.cs`.
- Review the generated C# before committing snapshot changes.

### Typical test flow
1) Write or update a case in `tests/cases/**.md` with C# source.
2) Commit and push; `Compile Test Cases` workflow compiles and updates dumped JSON in markdown.
3) Locally update snapshots with pytest (syrupy):
   - `pytest --snapshot-update`
4) Verify generated C# looks correct, then commit updated snapshots.
5) Later testing can be just `pytest` (compare against snapshots).

Common pytest flags:
- `-k <expr>`: run matching tests.
- `-vv`: verbose output.

## Lint & type check
- Ruff: `uv run ruff check .` (can auto-fix: `uv run ruff check . --fix`).
- Pyright: `uv run pyright` (requires deps from `uv sync --group dev`).

## Dependencies
- Control-flow structuring uses `numba-scfg` (see `pyproject.toml`).

## Workflows (.github/workflows)
- `ci.yml`: uv sync (dev), ruff, pyright, download `UdonModuleInfo.json` from secret URL, then `pytest -q -vv`.
- `compile-test-cases.yml`: Unity CI builds UdonSharp from markdown cases, updates dumped JSON blocks, commits back to repo.
- `generate-udon-module-info.yml`: Unity CI extracts `UdonModuleInfo.json` (artifact).
- `docs.yml`: builds Typst docs with `shiroa` and deploys to Cloudflare Pages.

## UdonModuleInfo.json
- Not stored in the repo (VRChat SDK license restrictions).
- CI can download it via `UDON_MODULE_INFO_URL` secret in `ci.yml`.
- Tests skip if the file is missing (see `tests/test_snapshots.py`).

## Local tooling notes
- Python >= 3.13, managed with `uv`.

## Udon background (quick primer for LLMs)
- Udon is a stack-based VM used by VRChat; Udon Program is the compiled artifact of UdonSharp.
- Bytecode is a sequence of big-endian `u32` opcodes and optional operands. `PC` advances by 4 or 8 bytes depending on opcode.
- Stack holds heap addresses (not raw values). Most operands are heap addresses too; exceptions are `JUMP` and `JUMP_IF_FALSE` operands (immediate targets).
- Key opcodes: `NOP`, `PUSH`, `POP`, `COPY`, `JUMP`, `JUMP_IF_FALSE`, `JUMP_INDIRECT`, `EXTERN`, `ANNOTATION`.
- Heap is an `IStrongBox[]` initialized from `HeapDump` (address, value, type).
- Entry points are public functions (from `UdonProgram.EntryPoints`), each points to a bytecode address.
- External calls use `externSignature` strings (e.g. `UnityEngineGameObject.__SetActive__SystemBoolean__SystemVoid`) resolved to `UdonExternDelegate` with a parameter count. The VM pops parameter addresses from stack and calls the delegate.
